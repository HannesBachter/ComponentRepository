//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

//------------------------------------------------------------------------
//
//  Copyright (C) 2018 Nayabrasul Shaik, Matthias Rollenhagen
//
//        shaik@hs-ulm.de, rollenhagen@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "SmartLaserFromRGBDServer component".
//
//  The method for converting 3D pointcloud to 2D laserscan is based on Mobile Robot Programming Toolkit (MRPT), http://www.mrpt.org/
//  https://github.com/MRPT/mrpt/blob/1371504fd3fdb891b92e80aa53eb26c4b33015cd/libs/obs/src/CObservation3DRangeScan.cpp
//--------------------------------------------------------------------------

//------------------------------------------------------------------------
//  For License : https://www.mrpt.org/License/
//  Copyright (c) 2005-2014, Individual contributors, see AUTHORS file
//  Copyright (c) 2005-2014, MAPIR group, University of Malaga
//  Copyright (c) 2012-2014, University of Almeria
//  All rights reserved.

//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are
//  met:
//  * Redistributions of source code must retain the above copyright
//        notice, this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//        notice, this list of conditions and the following disclaimer in the
//        documentation and/or other materials provided with the distribution.
//   * Neither the name of the copyright holders nor the
//        names of its contributors may be used to endorse or promote products
//        derived from this software without specific prior written permission.

//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//  'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
//  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE
//  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//--------------------------------------------------------------------------

#ifndef _LASERTASK_HH
#define _LASERTASK_HH

#include "LaserTaskCore.hh"
#include "LaserTaskCore.hh"
#include "CommBasicObjects/CommBasePose.hh"
#include "CommBasicObjects/CommMobileLaserScan.hh"
#include "DomainVision/CommRGBDImage.hh"

#include <opencv2/opencv.hpp>
#include <mrpt/poses/CPoint.h>

#include <armadillo.hh>
#include <vector>
#include <deque>

class LaserTask  : public LaserTaskCore
{
private:

	CommBasicObjects::CommMobileLaserScan laser_scan;
	DomainVision::CommRGBDImage rgbd_scan;
	CommBasicObjects::CommBaseState base_state;

	DomainVision::DepthFormatType depth_data_type;
	Smart::StatusCode status;
	bool first_image_flag;  /**use this flag to read intrinsic and extrinsic parameters from the first received RGBD image**/


	//these variables are derived from rgbd proterties, calculate only once
	float       hfov_rad;    ///< Horizontal field of View (in radians)
	float       vfov_rad;    ///< Vertical field of View (in radians)
	size_t nLaserRays;       ///< number of laser rays in a scan
	double start_angle;      ///< Angle correspond to first scan
	double angle_resolution; ///< Difference of angles between 2 consecutive rays


	float vertical_view;///< vertical field of view angle to be considered (specified from parameters)
	uint32_t min_dist;  ///< Minimum distance range
	uint32_t max_dist;  ///< Maximum distance range

	std::vector<float> vert_ang_tan;
	float tan_min;
	float tan_max;

	//distance of floor from camera center, we assume robot is on flat floor
	double camera_height_from_floor; //in meters


	// Color and Depth intrinsics
	struct st_intrinsics{
		int cols, rows;
		float cx, cy, fx, fy;
		float distortion_coeffs[5];
		DomainVision::ImageDistortionModel distortion_model;
	}color_intrinsics, depth_intrinsics;

	//Depth extrinsics with respect to color
	struct st_extrinsics{
		float rotation[9];
		float translation[3];
	}depth_to_color_extrinsics;

	//soure of rgbd image
	u_int8_t rgbd_source;
	std::vector<bool> floor_mask;
	//bool floor_mask[MAX_DEPTH_VALUES];
	std::deque<float> laser_ray_distances;
public:
	LaserTask(SmartACE::SmartComponent *comp);
	virtual ~LaserTask();
	
	virtual int on_entry();
	virtual int on_execute();
	virtual int on_exit();
	bool realsense_to_laserscan(DomainVision::CommRGBDImage& rgbd_scan, CommBasicObjects::CommMobileLaserScan& laser_scan);
	static double pi_to_pi(double angle);
	void display_parameters();
private:
	void init_laser_generation();
	double camera_height_from_floor_meters();
	void calcPointXYZ (const uint32_t& r, const uint32_t& c, const float &depth_val_meters, float &x, float &y, float &z,
			const st_intrinsics& intrinsics, const st_extrinsics& extrinsics);
	void transform (const st_extrinsics& extrinsics, float &x, float &y, float &z);
	void deproject(const st_intrinsics& intrinsics, const uint32_t& r, const uint32_t& c, const float &depth_val_meters, float &out_x, float &out_y, float &out_z);
	void project(const st_intrinsics& intrinsics, uint32_t& out_r, uint32_t& out_c, const float &in_x, const float &in_y, const float &in_z);
	void detect_floor(DomainVision::CommRGBDImage& rgbd_scan, std::vector<bool>& floor_mask);
	void read_intrinsics_extrinsics(const DomainVision::CommRGBDImage& rgbd_image);
	void comm_depth_image_to_cv_mat(DomainVision::CommDepthImage& comm_depth_image, cv::Mat& depth_mat);
	void find_depth_distances(DomainVision::CommDepthImage& comm_depth_image, std::deque<float>& laser_ray_distances);
	inline float get_depth(DomainVision::CommDepthImage& comm_depth_image, int row, int col);
	void set_laser_ray_distances(CommBasicObjects::CommMobileLaserScan& laser_scan, std::deque<float>& laser_ray_distances);
	void find_depth_distances_debug(DomainVision::CommDepthImage& comm_depth_image, std::deque<float>& laser_ray_distances);
	mrpt::poses::CPoint3D transormPointToRobotCoord(const mrpt::poses::CPoint3D & point, CommBasicObjects::CommPose3d& sensor_pose);
};

#endif
