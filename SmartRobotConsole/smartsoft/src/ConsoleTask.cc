//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz
//                2011 Dennis Stampfer
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft robot console component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
//  This component is for testing purposes only!
//
// --------------------------------------------------------------------------

#include "ConsoleTask.hh"
#include "SmartRobotConsole.hh"

#include <smartNSAdapterACE.hh>

#include <iostream>
#include <ios>
#include <string>
#include <iostream>
#include <string>
#include <string.h>
#include <stdio.h>

#ifndef LISP_SEPARATOR
#define LISP_SEPARATOR " ()\"\n"
#define LISP_STRING    1000
#endif
SmartACE::CommParameterRequest lispParamToParameterRequest(std::string lispString) {
	SmartACE::CommParameterRequest parameterRequest;

	char *param1  = (char *)NULL;
	char *input  = (char *)NULL;
	input = strdup(lispString.c_str());

	//find tag, the first element in parameter string
	do {
		param1 = strsep(&input,LISP_SEPARATOR);
	} while ((param1 != NULL) && (strlen(param1)==0));

	if(param1 == NULL)
		return parameterRequest;

	std::cout << "tag: " << param1 << std::endl;
	parameterRequest.setTag(param1);

	//find all other parameters
	int index = 1;
	while(input != NULL){
		//find next parameter value
		do {
			param1 = strsep(&input,LISP_SEPARATOR);
		} while ((param1 != NULL) && (strlen(param1)==0));

		if(param1 != NULL) {
			char indexStr[255];
			sprintf(indexStr,"%d",index);
			std::cout << "[" << indexStr << "] = " << param1 << std::endl;
			parameterRequest.setString(indexStr, param1);
			index++;
		}
	}

	std::cout << "lispParamToParameterRequest(" << parameterRequest << ")" << parameterRequest << std::endl;

	return parameterRequest;
}


ConsoleTask::ConsoleTask(SmartACE::SmartComponent *comp) 
:	ConsoleTaskCore(comp)
{
	std::cout << "constructor ConsoleTask\n";
}
ConsoleTask::~ConsoleTask() 
{
	std::cout << "destructor ConsoleTask\n";
}



int ConsoleTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	std::cout << "------------------------------------------------------------------------\n";
	std::cout << "| smartRobotConsole                                                    |\n";
	std::cout << "| ZAFH Servicerobotik Ulm                                              |\n";
	std::cout << "| Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz  |\n";
	return 0;
}
int ConsoleTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	



	//
	//	std::stringstream ss;
	//	ss << paramValue;

	//	int integer = 0;
	//	ss >> integer;
	//	if(!ss.fail()) {
	//		// can be casted to integer.
	//
	//
	//	} else {
	//		parameterRequest.setString()
	//	}
	//
	//	double dbl = 0.0;
	//	ss >> dbl;
	//	if(ss.fail()) {
	//		std::cout << "NOT AN DOUBLE" << std::endl;
	//	}
	//
	//	bool boolean = 0.0;
	//	ss >> boolean;
	//	if(ss.fail()) {
	//		std::cout << "NOT AN BOOLEAN" << std::endl;
	//	}









		Smart::StatusCode status;
		int mainMenuItem;

			// main menu
			std::cout << "------------------------------------------------------------------------\n";
			std::cout << "Main Menu:\n";

	//		std::cout << " 01 - Mapper state\n";
	//		std::cout << " 02 - Mapper parameter\n";
	//		std::cout << " 03 - Planner state\n";
	//		std::cout << " 04 - Planner parameter\n";
	//		std::cout << " 05 - ForkLift parameter\n";
	//		std::cout << " 06 - CDL state\n";
	//		std::cout << " 07 - CDL parameter\n";
	//		std::cout << " 08 - Base parameter\n";
	//		std::cout << " 09 - Speech-input state\n";
	//		std::cout << " 10 - Speech-input parameter\n";
	//		std::cout << " 11 - VisionFollowMeRegain state\n";
	//		std::cout << " 12 - VisionFollowMeRegain parameter\n";
	//		std::cout << " 13 - FollowMe parameter\n";
	//		std::cout << " 14 - PMD state\n";
	//		std::cout << " 15 - PMD parameter\n";
	//		std::cout << " 16 - Amcl parameter\n";
	//		std::cout << " 17 - Amcl state\n";
	//		std::cout << " 18 - Gmapping parameter\n";
	//		std::cout << " 19 - PTU state\n";
	//		std::cout << " 20 - PTU move (query)\n";
	//		std::cout << " 21 - PersonDetection param\n";
	//		std::cout << " 22 - SchunkGripper param\n";
	//		std::cout << " 23 - SLAM6DoF param\n";
	//		std::cout << " 24 - Calibrate Robot\n";
			std::cout << " 25 - F4 PathNavigation DEMOS\n";

			std::cout << " 97 - Parameter Client\n";
			std::cout << " 98 - State Client\n";
			std::cout << " 99 - Demos\n";
			std::cout << " 00 - EXIT\n";
			std::cout << "------------------------------------------------------------------------\n";

			std::cout << "\nplease choose number:  ";
			std::cin >> mainMenuItem;

			// sub menu
			switch (mainMenuItem)
			{
	#if 0
			// 1 - Mapper state
			case 1:
			{
				std::list<std::string> mainstates;
				//std::string stateServerName = "smartMapper";
				//CHS::StateMaster stateClient(component, stateServerName);

				std::cout << "connecting to: " << COMP->ini.mapperStateClient.serverName << "; " << COMP->ini.mapperStateClient.serviceName
						<< std::endl;
				status = COMP->mapperStateClient->connect(COMP->ini.mapperStateClient.serverName, COMP->ini.mapperStateClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT mapper state" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				// first get list of main states
				status = COMP->mapperStateClient->getAllMainStates(mainstates);
				if (status != Smart::SMART_OK)
				{
					std::cout << "could not connect to mapper state\n\n";
				} else
				{
					// print list of main states
					unsigned int itemNumber = 1;

					std::cout << "\nlist of possible main states: " << std::endl;
					for (std::list<std::string>::iterator iterator1 = mainstates.begin(); iterator1 != mainstates.end(); ++iterator1)
					{
						std::cout << std::setw(2) << itemNumber << " -- mainstate :  " << *iterator1 << std::endl;
						itemNumber++;
					}
					std::cout << std::setw(2) << itemNumber << " -- return to main menu" << std::endl;

					// ask which state should be sent
					std::cout << "\nplease choose number:  ";
					std::cin >> itemNumber;

					// check input
					if (itemNumber <= mainstates.size())
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for (unsigned int i = 1; i < itemNumber; i++)
						{
							++iterator1;
						}
						// send selected state
						COMP->mapperStateClient->setWaitState(*iterator1);
						std::cout << "state <" << *iterator1 << "> sent\n";
					}

				} // else

				break;
			} // case 1


				// 2 - Mapper parameter
			case 2:
			{
				CommNavigationObjects::CommMapperParameter cmd;
				std::string inString;

				//CHS::SendClient<Smart::CommMapperParameter> smartMapperParameterSendClient(component,"smartMapper","mapperParameter");
				std::cout << "connecting to: " << COMP->ini.mapperParameterClient.serverName << "; "
						<< COMP->ini.mapperParameterClient.serviceName << std::endl;
				status = COMP->mapperParameterClient->connect(COMP->ini.mapperParameterClient.serverName,
						COMP->ini.mapperParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT mapper parameter" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				std::cout << std::endl;
				std::cout << "CURPARAMETER ?xsize ?ysize ?xoff ?yoff ?id  : create current map (size/offset)\n";
				std::cout << "CURLTM DISABLE/ENABLE ?threshold            : preoccupy cur out of ltm each cycle\n";
				std::cout << "CUREMPTY ACCUMULATE/EMPTY                   : accumulate/clear cur map each cycle\n";
				std::cout << "CURSAVE ?filename                             : save current map (xml)\n";
				std::cout << "CURLOAD ?filename                             : load current map (xml)\n";
				std::cout << "CURLOADLTM                                  : load current map out of ltm\n";
				std::cout << "CURSAVEXPM ?filename                          : save current map (xpm)\n\n";
				std::cout << "LTMPARAMETER ?xsize ?ysize ?xpos ?ypos ?id  : create longterm map\n";
				std::cout << "LTMINITIALIZE ?init                         : clear map and initialize\n";
				std::cout << "LTMSAVE ?filename                             : save longterm map (xml)\n";
				std::cout << "LTMLOAD ?filename                             : load longterm map (xml)\n";
				std::cout << "LTMSAVEXPM ?filename                          : save longterm map (xpm)\n";
				std::cout << "LTMSAVEYAMLPGM ?filename                      : save longterm map (pgm)\n";
				std::cout << "LTMSAVEYAMLPPM ?filename                      : save longterm map (ppm)\n";
				std::cout << "LTMLOADYAML ?filename                         : load longterm map (yaml)\n\n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: command(param1)(param2)(param3)\n";
				std::cout << "       ltmparameter(80000)(80000)(-20000)(-40000)(0)\n";

				std::cout << "\nplease enter command:  ";

				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{

					cmd.set(inString);
					COMP->mapperParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}
				break;
			} // case 2


				// 3 - Planner state
			case 3:
			{
				//std::string stateServerName = "smartPlanner";
				std::list<std::string> mainstates;

				//Smart::SMARTStateClient stateClient(component, stateServerName);
				std::cout << "connecting to: " << COMP->ini.plannerStateClient.serverName << "; " << COMP->ini.plannerStateClient.serviceName
						<< std::endl;
				status = COMP->plannerStateClient->connect(COMP->ini.plannerStateClient.serverName, COMP->ini.plannerStateClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "ERROR CONNECTING planner state" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				// first get list of main states
				status = COMP->plannerStateClient->getAllMainStates(mainstates);
				if (status != Smart::SMART_OK)
				{
					std::cout << "could not connect to planner state \n\n";
				} else
				{
					// print list of main states
					unsigned int itemNumber = 1;

					std::cout << "\nlist of possible main states: " << std::endl;
					for (std::list<std::string>::iterator iterator1 = mainstates.begin(); iterator1 != mainstates.end(); ++iterator1)
					{
						std::cout << std::setw(2) << itemNumber << " -- mainstate :  " << *iterator1 << std::endl;
						itemNumber++;
					}
					std::cout << std::setw(2) << itemNumber << " -- return to main menu" << std::endl;

					// ask which state should be sent
					std::cout << "\nplease choose number:  ";
					std::cin >> itemNumber;

					// check input
					if (itemNumber <= mainstates.size())
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for (unsigned int i = 1; i < itemNumber; i++)
						{
							++iterator1;
						}
						// send selected state
						COMP->plannerStateClient->setWaitState(*iterator1);
						std::cout << "state <" << *iterator1 << "> sent\n";
					}

				} // else

				break;
			} // case 3


				// 4 - Planner parameter
			case 4:
			{
				//@TODO RobotConsole
				CommNavigationObjects::CommPlannerParameter cmd;
				std::string inString;

				//CHS::SendClient<Smart::CommPlannerParameter> smartPlannerParameterSendClient(component,"smartPlanner","plannerParameter");
				std::cout << "connecting to: " << COMP->ini.plannerParameterClient.serverName << "; "
						<< COMP->ini.plannerParameterClient.serviceName << std::endl;
				status = COMP->plannerParameterClient->connect(COMP->ini.plannerParameterClient.serverName,
						COMP->ini.plannerParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT planner parameter" << std::endl;
				}
				std::cout << "connected.\n";

				std::cout << std::endl;
				std::cout << "ID ?id  : set Planner_ID\n";
				std::cout << "DELETEGOAL       : delete all specified goals in path planner\n";
				std::cout << "SETDESTINATIONLINE ?xstart ?ystart ?xend ?yend : set destination line in path planner\n";
				std::cout << "SETDESTINATIONCIRCLE ?xcenter ?ycenter ?radius : set destination circle in path planner\n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: command(param1)(param2)(param3)\n";
				std::cout << "       setdestinationcircle(8000)(8000)(150)\n";

				std::cout << "\nplease enter command:  ";

				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{

					cmd.set(inString);
					COMP->plannerParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}
				break;

			} // case 4


				// 5 - Forklift parameter
			case 5:
			{
				CommForkliftObjects::CommForkliftParameter cmd;

				//CHS::SendClient<Smart::CommForkLiftCommand> smartForkLiftCommandSendClient(component,"SmartForkLiftServer","param");
				std::string inString;
				//CHS::SendClient<Smart::CommCdlParameter> smartCdlParameterSendClient(component,"smartCdlServer","cdlParameter");
				std::cout << "connecting to: " << COMP->ini.forkliftParameterClient.serverName << "; "
						<< COMP->ini.forkliftParameterClient.serviceName << std::endl;
				status = COMP->forkliftParameterClient->connect(COMP->ini.forkliftParameterClient.serverName,
						COMP->ini.forkliftParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "\n COULD NOT CONNECT TO forklift parameter \n\n";
				} else
				{
					std::cout << "connected.\n";
				}

				std::cout << "MOVE_ABS_MM                   : GOTO forklift position in mm\n";
				std::cout << "INITIALIZE                    : init forklift\n";
				std::cout << "SHUTDOWN                      : shutdown forklift\n";
				std::cout << "STOP                          : stop forklift movement\n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: command(param1)(param2)(param3)\n";
				std::cout << "        MOVE_ABS_MM(100)\n";
				std::cout << "\nplease enter command:  ";

				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{
					cmd.set(inString);
					COMP->forkliftParameterClient->send(cmd);
					std::cout << "sent.\n\n";
				}

				break;
			} // case 5


				// 6 - CDL state
			case 6:
			{
				//std::string stateServerName = "smartCdlServer";
				std::list<std::string> mainstates;
				//Smart::SMARTStateClient stateClient(component, stateServerName);

				std::cout << "connecting to: " << COMP->ini.cdlStateClient.serverName << "; " << COMP->ini.cdlStateClient.serviceName
						<< std::endl;
				status = COMP->cdlStateClient->connect(COMP->ini.cdlStateClient.serverName, COMP->ini.cdlStateClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT TO state client" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				// first get list of main states
				status = COMP->cdlStateClient->getAllMainStates(mainstates);
				if (status != Smart::SMART_OK)
				{
					std::cout << "could not connect to cdl state\n\n";
				} else
				{
					// print list of main states
					unsigned int itemNumber = 1;

					std::cout << "\nlist of possible main states: " << std::endl;
					for (std::list<std::string>::iterator iterator1 = mainstates.begin(); iterator1 != mainstates.end(); ++iterator1)
					{
						std::cout << std::setw(2) << itemNumber << " -- mainstate :  " << *iterator1 << std::endl;
						itemNumber++;
					}
					std::cout << std::setw(2) << itemNumber << " -- return to main menu" << std::endl;

					// ask which state should be sent
					std::cout << "\nplease choose number:  ";
					std::cin >> itemNumber;

					// check input
					if (itemNumber <= mainstates.size())
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for (unsigned int i = 1; i < itemNumber; i++)
						{
							++iterator1;
						}
						// send selected state
						COMP->cdlStateClient->setWaitState(*iterator1);
						std::cout << "state <" << *iterator1 << "> sent\n";
					}

				} // else


				break;
			} // case 6


				// 7 - CDL parameter
			case 7:
			{
				CommNavigationObjects::CommCdlParameter cmd;
				std::string inString;
				//CHS::SendClient<Smart::CommCdlParameter> smartCdlParameterSendClient(component,"smartCdlServer","cdlParameter");
				std::cout << "connecting to: " << COMP->ini.cdlParameterClient.serverName << "; " << COMP->ini.cdlParameterClient.serviceName
						<< std::endl;
				status = COMP->cdlParameterClient->connect(COMP->ini.cdlParameterClient.serverName, COMP->ini.cdlParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT TO cdl parameter" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				std::cout << std::endl;
				std::cout << "STRATEGY REACTIVE / JOYSTICK / BACKWARD\n";
				std::cout << "         APPROACH_HALT / APPROACH\n";
				std::cout << "         TURN / ROTATE / FOLLOW\n";
				std::cout << "         APPROACH_FLAT_SURF \n";
				std::cout << "		   APPROACH_COVERAGE                  : set the cdl strategy\n";
				std::cout << "FREEBEHAVIOR ACTIVATE / DEACTIVATE          : freebehavior in stall situation\n";
				std::cout << "LOOKUPTABLE DEFAULT / SECOND                : set cdl lookup table\n";
				std::cout << "TRANSVEL ?vmin ?vmax                        : set translation velocity min,max in mm/s\n";
				std::cout << "ROTVEL ?wmin ?wmax (deg/sec)                : set rotational velocity min,max in deg/s\n";
				std::cout << "GOALMODE ABSOLUTE / PLANNER / PERSON /\n";
				std::cout << "         SAVED / ANGLEABSOLUT /\n";
				std::cout << "         ANGLERELATIVE                      : set the cdl goal mode\n";
				std::cout << "GOALREGION ?x ?y ?a ?id (mm,mm,deg,id)      : set cdl goal x,y,heading,goalId\n";
				std::cout << "APPROACHDIST ?dist (mm)                     : set cdl goal approach distance in mm\n";
				std::cout << "SAFETYCL ?dist (mm)                         : set cdl global safety clearance distance in mm\n";
				std::cout << "ID ?id                                      : set CDL_ID\n";
				std::cout << "SAVECURPOS ?id                              : save current robot pose (for relative movements)\n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: command(param1)(param2)(param3)\n";
				std::cout << "       strategy(reactive) or transvel(0)(500)\n";

				std::cout << "\nplease enter command:  ";

				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{

					cmd.set(inString);
					COMP->cdlParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}
				break;
			} // case 7


				// 8 - Base parameter
			case 8:
			{
				CommBasicObjects::CommBaseParameter cmd;
				std::string inString;

				//CHS::SendClient<Smart::CommBaseParameter> smartBaseParameterSendClient(component,"smartPioneerBaseServer","baseParameter");
				std::cout << "connecting to: " << COMP->ini.baseParameterClient.serverName << "; " << COMP->ini.baseParameterClient.serviceName
						<< std::endl;
				status
						= COMP->baseParameterClient->connect(COMP->ini.baseParameterClient.serverName,
								COMP->ini.baseParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT TO base parameter" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				std::cout << std::endl;
				std::cout << "SONAR 0/1  : sonar on/off \n";
				std::cout << "RESET      : reset the Base Postion \n";
				std::cout << "             !!ALL POSITIONS ARE RESET!! \n";
				std::cout << "             !!INCLUDING THE RAW POS!! \n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: command(param1)(param2)(param3)\n";
				std::cout << "       setdestinationcircle(8000)(8000)(150)\n";

				std::cout << "\nplease enter command:  ";

				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{

					cmd.set(inString);
					COMP->baseParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}
				break;

			} // case 8


				// 9 - Speech-input state
			case 9:
			{
				//std::string stateServerName = "smartSpeechInputServer";
				std::list<std::string> mainstates;

				//Smart::SMARTStateClient stateClient(component, stateServerName);
				std::cout << "connecting to: " << COMP->ini.speechStateClient.serverName << "; " << COMP->ini.speechStateClient.serviceName
						<< std::endl;
				status = COMP->speechStateClient->connect(COMP->ini.speechStateClient.serverName, COMP->ini.speechStateClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT to speech state" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				// first get list of main states
				status = COMP->speechStateClient->getAllMainStates(mainstates);
				if (status != Smart::SMART_OK)
				{
					std::cout << "could not connect to " << COMP->ini.speechStateClient.serverName << "\n\n";
				} else
				{
					// print list of main states
					unsigned int itemNumber = 1;

					std::cout << "\nlist of possible main states: " << std::endl;
					for (std::list<std::string>::iterator iterator1 = mainstates.begin(); iterator1 != mainstates.end(); ++iterator1)
					{
						std::cout << std::setw(2) << itemNumber << " -- mainstate :  " << *iterator1 << std::endl;
						itemNumber++;
					}
					std::cout << std::setw(2) << itemNumber << " -- return to main menu" << std::endl;

					// ask which state should be sent
					std::cout << "\nplease choose number:  ";
					std::cin >> itemNumber;

					// check input
					if (itemNumber <= mainstates.size())
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for (unsigned int i = 1; i < itemNumber; i++)
						{
							++iterator1;
						}
						// send selected state
						COMP->speechStateClient->setWaitState(*iterator1);
						std::cout << "state <" << *iterator1 << "> sent\n";
					}

				} // else


				break;
			} // case 9


				// 10 - Speech-Input parameter
			case 10:
			{
				CommSpeechObjects::CommSpeechInputParameter cmd;
				std::string inString;

				//CHS::SendClient<Smart::CommSpeechInputParameter> smartSpeechInputParameterSendClient(component,"smartSpeechInputServer","speechInputParameter");
				std::cout << "connecting to: " << COMP->ini.speechParameterClient.serverName << "; "
						<< COMP->ini.speechParameterClient.serviceName << std::endl;
				status = COMP->speechParameterClient->connect(COMP->ini.speechParameterClient.serverName,
						COMP->ini.speechParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT to speechParameterClient" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				std::cout << std::endl;
				std::cout << "SETGRAMMER ?file_name                       : set the speech input grammer\n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: command(param1)(param2)(param3)\n";
				std::cout << "       setgrammer(/home/user/grammer.gxml)\n";

				std::cout << "\nplease enter command:  ";

				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{

					cmd.set(inString);
					COMP->speechParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}
				break;
			} // case 10


				// 13 - unused
			case 13:
			{
				std::cout << "connecting to: " << COMP->ini.followMeParameterClient.serverName << "; "
						<< COMP->ini.followMeParameterClient.serviceName << std::endl;
				status = COMP->followMeParameterClient->connect(COMP->ini.followMeParameterClient.serverName,
						COMP->ini.followMeParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT followMeParameterClient" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				CommTrackingObjects::CommFollowMeParameter cmd;

				std::cout << std::endl;
				std::cout << "parameters: " << std::endl;
				std::cout << "RESET(px)(py)     : position relative to robot\n";
				std::cout << "SETMAXCOV(px)     : max distance radius until lost [?]\n";

				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: command(param1)(param2)(param3)\n";
				std::cout << "       strategy(reactive) or transvel(0)(500)\n";

				std::cout << "\nplease enter command:  ";

				std::string inString;
				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{

					cmd.set(inString);
					COMP->followMeParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}

				break;
			} // case 13


				// 16 - Amcl parameter
			case 16:
			{
				CommNavigationObjects::CommAmclParameter cmd;
				std::string inString;

				// CHS::SendClient<CommAmclObjects::CommAmclParameter> smartAmclParameterSendClient(component,"SmartAmcl","param");
				std::cout << "connecting to: " << COMP->ini.amclParameterClient.serverName << "; " << COMP->ini.amclParameterClient.serviceName
						<< std::endl;
				status
						= COMP->amclParameterClient->connect(COMP->ini.amclParameterClient.serverName,
								COMP->ini.amclParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT amclParameterClient" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				std::cout << std::endl;
				std::cout << "GLOBALLOCALIZATION         : trigger global localization\n";
				std::cout << "INITIALPOSE ?x ?y ?a       : initialize localization at pose\n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: command(param1)\n";
				std::cout << "       initialpose(0)(0)(0)\n";

				std::cout << "\nplease enter command:  ";

				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{
					cmd.set(inString);
					COMP->amclParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}
				break;
			} // case 16


				// 17 - Amcl state
			case 17:
			{
				//std::string stateServerName = "SmartAmcl";
				std::list<std::string> mainstates;

				//Smart::SMARTStateClient stateClient(component, stateServerName, "state");
				std::cout << "connecting to: " << COMP->ini.amclStateClient.serverName << "; " << COMP->ini.amclStateClient.serviceName
						<< std::endl;
				status = COMP->amclStateClient->connect(COMP->ini.amclStateClient.serverName, COMP->ini.amclStateClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT amclStateClient" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				// first get list of main states
				status = COMP->amclStateClient->getAllMainStates(mainstates);
				if (status != Smart::SMART_OK)
				{
					std::cout << "could not connect to amcl state\n\n";
				} else
				{
					// print list of main states
					unsigned int itemNumber = 1;

					std::cout << "\nlist of possible main states: " << std::endl;
					for (std::list<std::string>::iterator iterator1 = mainstates.begin(); iterator1 != mainstates.end(); ++iterator1)
					{
						std::cout << std::setw(2) << itemNumber << " -- mainstate :  " << *iterator1 << std::endl;
						itemNumber++;
					}
					std::cout << std::setw(2) << itemNumber << " -- return to main menu" << std::endl;

					// ask which state should be sent
					std::cout << "\nplease choose number:  ";
					std::cin >> itemNumber;

					// check input
					if (itemNumber <= mainstates.size())
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for (unsigned int i = 1; i < itemNumber; i++)
						{
							++iterator1;
						}
						// send selected state
						COMP->amclStateClient->setWaitState(*iterator1);
						std::cout << "state <" << *iterator1 << "> sent\n";
					}

				} // else

				break;
			} // case 17


				// 18 - GMapping parameter
			case 18:
			{
				CommNavigationObjects::CommGMappingParameter cmd;
				std::string inString;

				//CHS::SendClient<Smart::CommGMappingParameter> smartGMappingParameterSendClient(component,"smartGmapping","param");
				std::cout << "connecting to: " << COMP->ini.gmappingParameterClient.serverName << "; "
						<< COMP->ini.gmappingParameterClient.serviceName << std::endl;
				status = COMP->gmappingParameterClient->connect(COMP->ini.gmappingParameterClient.serverName,
						COMP->ini.gmappingParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT gmappingParameterClient" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				std::cout << std::endl;
				std::cout << "SAVEMAP ?filename       : save the girdmap to pgm and yaml \n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: command(param1)\n";
				std::cout << "       initialpose(0)(0)(0)\n";

				std::cout << "\nplease enter command:  ";

				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{
					cmd.set(inString);
					COMP->gmappingParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}
				break;
			} // case 18


				// 19 - PTU state
			case 19:
			{
				//Smart::SMARTStateClient stateClient(component, "SmartPTUServer", "stateServer");
				// activate PTU
				//stateClient.setWaitState("active");

				std::list<std::string> mainstates;

				//Smart::SMARTStateClient stateClient(component, stateServerName, "state");
				std::cout << "connecting to: " << COMP->ini.ptuStateClient.serverName << "; " << COMP->ini.ptuStateClient.serviceName
						<< std::endl;
				status = COMP->ptuStateClient->connect(COMP->ini.ptuStateClient.serverName, COMP->ini.ptuStateClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT ptuStateClient" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				// first get list of main states
				status = COMP->ptuStateClient->getAllMainStates(mainstates);
				if (status != Smart::SMART_OK)
				{
					std::cout << "could not connect to amcl state\n\n";
				} else
				{
					// print list of main states
					unsigned int itemNumber = 1;

					std::cout << "\nlist of possible main states: " << std::endl;
					for (std::list<std::string>::iterator iterator1 = mainstates.begin(); iterator1 != mainstates.end(); ++iterator1)
					{
						std::cout << std::setw(2) << itemNumber << " -- mainstate :  " << *iterator1 << std::endl;
						itemNumber++;
					}
					std::cout << std::setw(2) << itemNumber << " -- return to main menu" << std::endl;

					// ask which state should be sent
					std::cout << "\nplease choose number:  ";
					std::cin >> itemNumber;

					// check input
					if (itemNumber <= mainstates.size())
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for (unsigned int i = 1; i < itemNumber; i++)
						{
							++iterator1;
						}
						// send selected state
						COMP->ptuStateClient->setWaitState(*iterator1);
						std::cout << "state <" << *iterator1 << "> sent\n";
					}

				} // else


				break;
			} // PTU move


				// 20 - PTU move
			case 20:
			{
				int pan = 0, tilt = 0;

				std::cout << "\nenter pan [deg]:  ";
				std::cin >> pan;

				std::cout << "enter tilt [deg]:  ";
				std::cin >> tilt;

				std::cout << "\nmove to: " << pan << ", " << tilt << std::endl;

				//CHS::QueryClient<CommPTUObjects::CommPTUMoveRequest, CommPTUObjects::CommPTUMoveResponse> smartPTUMoveQueryClient(component, "SmartPTUServer", "movePTU");
				std::cout << "connecting to: " << COMP->ini.ptuQueryClient.serverName << "; " << COMP->ini.ptuQueryClient.serviceName
						<< std::endl;
				status = COMP->ptuQueryClient->connect(COMP->ini.ptuQueryClient.serverName, COMP->ini.ptuQueryClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT ptuStateClient" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}

				CommPTUObjects::CommPTUMoveRequest request;
				CommPTUObjects::CommPTUMoveResponse response;

				request.set_move_mode(CommPTUObjects::PTUMoveFlag::PAN_TILT_ABSOLUTE);
				request.set_pan(pan * (M_PI / 180.0));
				request.set_tilt(tilt * (M_PI / 180.0));
				std::cout << "Sending move request...\n";
				//smartPTUMoveQueryClient.query(request, response);
				COMP->ptuQueryClient->query(request, response);
				if (response.get_status() == CommPTUObjects::PTUMoveStatus::GOAL_REACHED)
				{
					std::cout << "move was successful\n";
				} else
				{
					std::cout << "error while moving\n";
				}

				break;
			} // case 20


				// 21 - PersonDetectionParam
			case 21:
			{
				CommPersonDetectionObjects::CommPersonDetectionParameter cmd;
				std::string inString;

				std::cout << "connecting to: " << COMP->ini.personDetectionParameterClient.serverName << "; "
						<< COMP->ini.personDetectionParameterClient.serviceName << std::endl;
				status = COMP->personDetectionParameterClient->connect(COMP->ini.personDetectionParameterClient.serverName,
						COMP->ini.personDetectionParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT personDetectionParameterClient" << std::endl;
					break;
				} else
				{
					std::cout << "connected.\n";
				}

				std::cout << std::endl;
				std::cout << "MODE: ONESHOT/CONTINUOUS\n";
				std::cout << "TYPE: SINGLESCAN/FULLSCAN\n";
				std::cout << "PMANAGER: RESET/ACTIVATE/DEACTIVATE\n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: command(param1)\n";
				std::cout << "       mode(oneshot)\n";

				std::cout << "\nplease enter command:  ";

				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{
					cmd.set(inString);
					COMP->personDetectionParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}
				break;
			} // case 21


				// 22 - SchunkGripperParam
			case 22:
			{
				CommManipulatorObjects::CommGripperParam cmd;
				std::string inString;

				std::cout << "connecting to: " << COMP->ini.schunkGripperParameterClient.serverName << "; "
						<< COMP->ini.schunkGripperParameterClient.serviceName << std::endl;
				status = COMP->schunkGripperParameterClient->connect(COMP->ini.schunkGripperParameterClient.serverName,
						COMP->ini.schunkGripperParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT schunkGripperParameterClient" << std::endl;
					break;
				} else
				{
					std::cout << "connected.\n";
				}

				std::cout << std::endl;
				std::cout << "OPEN\n";
				std::cout << "CLOSE\n";
				std::cout << "ACC(value) - acceleration\n";
				std::cout << "VEL(value) - velocity\n";
				std::cout << "CUR(value) - current\n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: cur(6)\n";
				std::cout << "       vel(200)\n";

				std::cout << "\nplease enter command:  ";

				std::cin >> inString;
				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{
					cmd.set(inString);
					COMP->schunkGripperParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}
				break;
			} // case 22

			// 23 - SLAM6DoF parameter
			case 23:
			{
				CommNavigationObjects::Comm6DoFSLAMParameter cmd;
				std::string inString;

				// connect to all services
				std::cout << "connecting to: "
						<< COMP->ini.slam6DoFParameterClient.serverName << "; "
						<< COMP->ini.slam6DoFParameterClient.serviceName << std::endl;

				status = COMP->slam6DoFParameterClient->connect(
						COMP->ini.slam6DoFParameterClient.serverName,
						COMP->ini.slam6DoFParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
						std::cout << "COULD NOT CONNECT slam6DoFParameterClient" << std::endl;
						break;
				}else
				{
						std::cout << "connected.\n";
				}


				std::cout << std::endl;
				std::cout << "SLAM_MODE\n";
				std::cout << "POSETRACKING_MODE\n";
				std::cout << "m to return to main menu" << std::endl;

				std::cout << "\nplease enter command:  ";

				std::cin >> inString;

				std::cout << "your input: " << inString << std::endl;

				if (strcasecmp("m", inString.c_str()) != 0)
				{
					cmd.set(inString);
					COMP->slam6DoFParameterClient->send(cmd);
					std::cout << "send.\n\n";
				}
				break;
			} // case 23



			// 24 - Calibrate Robot
			case 24:
			{
				CommBasicObjects::CommNavigationVelocity cmd;
				std::string inString;

				// connect to all services
				std::cout << "connecting to: "
						<< COMP->ini.baseVelocitySendClient.serverName << "; "
						<< COMP->ini.baseVelocitySendClient.serviceName << std::endl;

				status = COMP->baseVelocitySendClient->connect(
						COMP->ini.baseVelocitySendClient.serverName,
						COMP->ini.baseVelocitySendClient.serviceName);

				if (status != Smart::SMART_OK)
				{
						std::cout << "COULD NOT CONNECT baseVelocitySendClient" << std::endl;
						break;
				}else
				{
						std::cout << "connected.\n";
				}


				std::cout << "connecting to: "
						<< COMP->ini.basePositionPushTimedClient.serverName << "; "
						<< COMP->ini.basePositionPushTimedClient.serviceName << std::endl;

				status = COMP->basePositionPushTimedClient->connect(
						COMP->ini.basePositionPushTimedClient.serverName,
						COMP->ini.basePositionPushTimedClient.serviceName);

				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT basePositionPushTimedClient" << std::endl;
					break;
				}
				else {
					std::cout << "connected.\n";
					COMP->basePositionPushTimedClient->subscribe(COMP->ini.basePositionPushTimedClient.interval);
				}


				std::cout << "connecting to: " << COMP->ini.baseParameterClient.serverName << "; " << COMP->ini.baseParameterClient.serviceName
						<< std::endl;
				status
						= COMP->baseParameterClient->connect(COMP->ini.baseParameterClient.serverName,
								COMP->ini.baseParameterClient.serviceName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "COULD NOT CONNECT TO base parameter" << std::endl;
				} else
				{
					std::cout << "connected.\n";
				}


				std::cout << std::endl;
				std::cout << "  1 - move forward" << std::endl;
				std::cout << "  2 - rotate" << std::endl;
				std::cout << "  m to return to main menu" << std::endl;

				std::cout << "\nplease choose number:  ";
				int subMenuItem;
				std::cin >> subMenuItem;

				switch (subMenuItem)
				{

				// Move forward
				case 1:
				{
					std::cout << "\nmove forward [mm]:  ";

					std::cin >> inString;
					std::cout << "your input: " << inString << std::endl;

					if (strcasecmp("m", inString.c_str()) != 0)
					{
						CommBasicObjects::CommBaseParameter baseParam;
						baseParam.set("RESET");
						COMP->baseParameterClient->send(baseParam);
						std::cout << "RESET BASE!!!.\n\n";
						std::cout.flush();

						int dist = 0;
						int distWanted = atoi(inString.c_str());

						CommBasicObjects::CommBaseState baseState;

						COMP->basePositionPushTimedClient->getUpdateWait(baseState);
						CommBasicObjects::CommPosition3d pos = baseState.get_base_raw_position().get_base_pose3d().get_position();
						std::cout << "Start Pos: " << pos.get_x() << ", " << pos.get_y() << ", " << std::endl;

						while (dist < abs(distWanted))
						{
							if (distWanted > 0)
								cmd.set_vX(300);
							else
								cmd.set_vX(-300);

							cmd.set_omega(0);
							COMP->baseVelocitySendClient->send(cmd);

							COMP->basePositionPushTimedClient->getUpdateWait(baseState);
							pos = baseState.get_base_raw_position().get_base_pose3d().get_position();
							dist = sqrt(pos.get_x() * pos.get_x() + pos.get_y() * pos.get_y());
						}

						cmd.set_vX(0);
						cmd.set_omega(0);
						COMP->baseVelocitySendClient->send(cmd);

						std::cout << "Dist driven: " << dist << std::endl;

						COMP->basePositionPushTimedClient->getUpdateWait(baseState);
						pos = baseState.get_base_raw_position().get_base_pose3d().get_position();
						std::cout << "End Pos: " << pos.get_x() << ", " << pos.get_y() << std::endl;
					}
					break;
				}

				// Rotate
				case 2:
				{
					std::cout << "\nrotate [deg]:  ";

					std::cin >> inString;
					std::cout << "your input: " << inString << std::endl;

					if (strcasecmp("m", inString.c_str()) != 0)
					{
						CommBasicObjects::CommBaseParameter baseParam;
						baseParam.set("RESET");
						COMP->baseParameterClient->send(baseParam);
						std::cout << "RESET BASE!!!.\n\n";
						std::cout.flush();

						double curAngle = 0;
						double lastAngle=0;
						double totalAngle = 0;
						double angleWanted = atof(inString.c_str()) * M_PI/180.0;

						CommBasicObjects::CommBaseState baseState;

						COMP->basePositionPushTimedClient->getUpdateWait(baseState);
						std::cout << "angle: " << baseState.get_base_raw_position().get_base_azimuth() << std::endl;

						std::cout << "wanted angle: " << angleWanted * 180/M_PI << " deg" << std::endl;
						while (totalAngle < fabs(angleWanted))
						{
							if (angleWanted > 0)
								cmd.set_omega(M_PI/8);
							else
								cmd.set_omega(-M_PI/8);

							cmd.set_vX(0);
							COMP->baseVelocitySendClient->send(cmd);

							COMP->basePositionPushTimedClient->getUpdateWait(baseState);
							curAngle = baseState.get_base_raw_position().get_base_azimuth();
							//std::cout << "angle: " << curAngle << std::endl;

							if (lastAngle >= M_PI_2 && curAngle < -M_PI_2){
								totalAngle += fabs(M_PI + curAngle + M_PI - lastAngle);
								//std::cout << "if - " << curAngle << ", " << lastAngle << " --- ";
							}
							else if (lastAngle < -M_PI_2 && curAngle >= M_PI_2) {
								totalAngle += fabs(M_PI + lastAngle + M_PI - curAngle);
								//std::cout << "else if - " << curAngle << ", " << lastAngle << " --- ";
							}
							else {
								totalAngle += fabs(curAngle - lastAngle);
								//std::cout << "else - " << curAngle << ", " << lastAngle << " --- ";
							}

							lastAngle = curAngle;
							//std::cout << "total: " << totalAngle << std::endl;
						}

						cmd.set_vX(0);
						cmd.set_omega(0);
						COMP->baseVelocitySendClient->send(cmd);

						std::cout << "Angle rotated: " << totalAngle * 180/M_PI  << " deg" << std::endl;

						COMP->basePositionPushTimedClient->getUpdateWait(baseState);
						std::cout << "angle: " << baseState.get_base_raw_position().get_base_azimuth() << std::endl;
					}
					break;
				}


				}


				break;
			} // 24 - Calibrate Robot
	#endif



			case 25: {
				std::cout<<"path navigation DEMOs"<<std::endl;

	 			SmartACE::CommParameterRequest parameterRequest;
	                        SmartACE::CommParameterResponse parameterResponse;
	                        Smart::StatusCode status;
				//TODO
			    status = COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMROBOTINOOBJECTS.PATHNAVIGATIONPARAMS.SETROBOTID(\"1\")"), parameterResponse, "SmartPathNavigation1", "param");
			    status = COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMIT"), parameterResponse, "SmartPathNavigation1", "param");
			    status = COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMROBOTINOOBJECTS.PATHNAVIGATIONPARAMS.SETROBOTID(\"2\")"), parameterResponse, "SmartPathNavigation2", "param");
			    status = COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMIT"), parameterResponse, "SmartPathNavigation2", "param");

			    int s1,s2,g1,g2;
			    std::cout<<"Start for robot1:";
			    std::cin>>s1;
			    std::cout<<"Goal for robot2:";
			    std::cin>>g1;

			    std::cout<<"Start for robot2:";
			    std::cin>>s2;
			    std::cout<<"Goal for robot2:";
			    std::cin>>g2;


			    std::stringstream ss;
			    ss << "COMMROBOTINOOBJECTS.PATHNAVIGATIONPARAMS.SET_GOAL((" <<s1<<" " << g1 <<"))";
			    status = COMP->paramMaster->sendParameterWait(lispParamToParameterRequest(ss.str()), parameterResponse, "SmartPathNavigation1", "param");
			    ss.str("");
			    ss << "COMMROBOTINOOBJECTS.PATHNAVIGATIONPARAMS.SET_GOAL((" <<s2<<" " << g2 <<"))";
			    status = COMP->paramMaster->sendParameterWait(lispParamToParameterRequest(ss.str()), parameterResponse, "SmartPathNavigation2", "param");

			    std::cout<<"Start?";
			    std::cin>>s1;

			    COMP->stateMaster->setWaitState("moverobot", "SmartPathNavigation1", "state");
			    COMP->stateMaster->setWaitState("moverobot", "SmartPathNavigation2", "state");

				std::cout << "\n\n>>> Reply: " << status << std::endl;

				break;
	  			}






			case 97: {

			    SmartACE::NSKeyType searchPattern;
				searchPattern.names[SmartACE::NSKeyType::PATTERN_NAME] = ACE_TEXT("Query");
				searchPattern.names[SmartACE::NSKeyType::SERVICE_NAME] = ACE_TEXT("*");
				searchPattern.names[SmartACE::NSKeyType::COMMOBJ1_NAME] = ACE_TEXT("CommParameter::CommParameterRequest");
				searchPattern.names[SmartACE::NSKeyType::COMMOBJ2_NAME] = ACE_TEXT("CommParameter::CommParameterResponse");

				ACE_Unbounded_Queue<SmartACE::NSKeyType> state_comps = SmartACE::NAMING::instance()->getEntriesForMatchingPattern(searchPattern);

				std::vector<SmartACE::NSKeyType> list_of_state_clients;
				int input;
				std::string paramServerName;
				std::string portName;
				std::cout << "\n------------------------------------------------------------------------\n";
				std::cout << "List of Components with Parameter: " << std::endl;

				unsigned int i = 0;
				for (ACE_Unbounded_Queue_Iterator<SmartACE::NSKeyType> iter (state_comps);
				   !iter.done ();
				   iter.advance ())
				{
					SmartACE::NSKeyType *comp = 0;
					iter.next (comp);

					std::cout << i << " - " << comp->names[SmartACE::NSKeyType::COMP_NAME] << ":" << comp->names[SmartACE::NSKeyType::SERVICE_NAME] << std::endl;
					list_of_state_clients.push_back(*comp);
					i++;
				}

				std::cout << "99 - other" << std::endl;
				std::cout << "Enter component to connect to: ";
				std::cin >> input;
				if (input == 99)
				{
					std::cout << "Enter Component name: ";
					std::cin >> paramServerName;
					std::cout << "Enter Port name: ";
					std::cin >> portName;
				} else
				{
					paramServerName = list_of_state_clients[input].names[SmartACE::NSKeyType::COMP_NAME].c_str();
					portName = list_of_state_clients[input].names[SmartACE::NSKeyType::SERVICE_NAME].c_str();
				}

				std::cout << "\n\n Send parameters to " << paramServerName << " " << std::endl;


				SmartACE::CommParameterRequest parameterRequest;
				SmartACE::CommParameterResponse parameterResponse;
				Smart::StatusCode status;


	/****************
				std::string paramName;
				std::cout << "Parameter name: ";
				std::cin >> paramName;

				parameterRequest.setTag(paramName);

				std::cout << "\n\n now enter values separated by \\n, send with '-'" << std::endl;

				int paramCounter = 1;
				std::string paramValue;

				while(true) {
					std::cout << paramName << "[" << paramCounter << "] = ";
					std::cin >> paramValue;
					if(paramValue == "-")
						break;

					std::stringstream s;
					s << paramCounter;
					parameterRequest.setString(s.str(), paramValue);

					paramCounter++;
				}
	*****/

				std::cout << "\n\nEnter parameter to send in lisp syntax: e.g. PARAM(v1)(v2)" << std::endl;
				std::cout << "> ";
				std::string parameterString;
				std::cin >> parameterString;

				parameterRequest = lispParamToParameterRequest(parameterString);
				std::cout << parameterRequest << std::endl;
				status = COMP->paramMaster->sendParameterWait(parameterRequest, parameterResponse, paramServerName, portName);
				std::cout << "\n\n>>> Reply: " << status << std::endl;
				sleep(1);



				break;
			}










				// 98 - Universal state client
			case 98:
			{

				SmartACE::NSKeyType searchPattern;
				searchPattern.names[SmartACE::NSKeyType::PATTERN_NAME] = ACE_TEXT("Query");
				searchPattern.names[SmartACE::NSKeyType::SERVICE_NAME] = ACE_TEXT("state");
				searchPattern.names[SmartACE::NSKeyType::COMMOBJ1_NAME] = ACE_TEXT("Smart::SMARTStateRequest");
				searchPattern.names[SmartACE::NSKeyType::COMMOBJ2_NAME] = ACE_TEXT("Smart::SMARTStateResponse");

				ACE_Unbounded_Queue<SmartACE::NSKeyType> state_comps = SmartACE::NAMING::instance()->getEntriesForMatchingPattern(searchPattern);

				std::vector<SmartACE::NSKeyType> list_of_state_clients;
				int input;
				std::string stateServerName;
				std::string portName;
				std::cout << "\n------------------------------------------------------------------------\n";
				std::cout << "List of Components with State: " << std::endl;

				unsigned int i = 0;
				for (ACE_Unbounded_Queue_Iterator<SmartACE::NSKeyType> iter (state_comps);
				   !iter.done ();
				   iter.advance ())
				{
					SmartACE::NSKeyType *comp = 0;
					iter.next (comp);

					std::cout << i << " - " << comp->names[SmartACE::NSKeyType::COMP_NAME] << std::endl;
					list_of_state_clients.push_back(*comp);
					i++;
				}

				std::cout << "99 - other" << std::endl;
				std::cout << "Enter component to connect to: ";
				std::cin >> input;
				if (input == 99)
				{
					std::cout << "Enter Component name: ";
					std::cin >> stateServerName;
					std::cout << "Enter Port name: ";
					std::cin >> portName;
				} else
				{
					stateServerName = list_of_state_clients[input].names[SmartACE::NSKeyType::COMP_NAME].c_str();
					portName = list_of_state_clients[input].names[SmartACE::NSKeyType::SERVICE_NAME].c_str();
				}

				std::list<std::string> mainstates;
				//CHS::StateMaster stateClient(COMP->component, stateServerName, portName);
				//CHS::StateMaster stateClient(COMP->component);
				// first get list of main states
				//status = stateClient.getAllMainStates(mainstates, stateServerName, portName);
				status = COMP->stateMaster->getAllMainStates(mainstates, stateServerName, portName);
				if (status != Smart::SMART_OK)
				{
					std::cout << "could not connect to " << stateServerName <<" error: "<<status <<"\n\n";
				} else
				{
					// print list of main states
					unsigned int itemNumber = 1;

					std::cout << "\nlist of possible main states, in component " << stateServerName << ": " << std::endl;
					for (std::list<std::string>::iterator iterator1 = mainstates.begin(); iterator1 != mainstates.end(); ++iterator1)
					{
						std::cout << std::setw(2) << itemNumber << " -- mainstate :  " << *iterator1 << std::endl;
						itemNumber++;
					}
					std::cout << std::setw(2) << itemNumber << " -- return to main menu" << std::endl;

					// ask which state should be sent
					std::cout << "\nplease choose number:  ";
					std::cin >> itemNumber;

					// check input
					if (itemNumber <= mainstates.size())
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for (unsigned int i = 1; i < itemNumber; i++) {
							++iterator1;
						}
						// send selected state
						COMP->stateMaster->setWaitState(*iterator1, stateServerName, portName);
						std::cout << "state <" << *iterator1 << "> sent\n";
					}

				} // else

				break;
			} // case 98


				// 99 - Demo
			case 99:
			{
				unsigned int itemNumber;
				std::list<std::string> mainstates;

				int input;
				std::string str;

				std::cout << std::endl;
				std::cout << "(1) Demo 1 Introduction robot speechoutput\n";
				std::cout << "(2) Demo 2 Planner-CDL GOTO \n";
				std::cout << "(3) Demo 3 CDL Reactive Mode \n";
				std::cout << "(4) Demo 4 Cdl Joystick Mode \n";
				std::cout << "(5) Demo 5 Follow Me \n";
				std::cout << "(6) Demo 6 PlannerSpanningTreeCoverage \n";
				std::cout << "(0) to return to main menu" << std::endl;

				std::cout << std::endl;
				std::cout << "usage: 1\n";

				std::cout << "\nplease enter command:  ";

				std::cin >> input;
				std::cout << "your input: " << input << std::endl;

				switch (input)
				{
	#if 0
				/////////////////////////////////
				// Demo 1 welcome the audience
				/////////////////////////////////
				case 1:
				{
					// Turn towards the audience
					CHS::SendClient<Smart::CommCdlParameter> smartCdlParameterSendClient(component,"smartCdlServer","cdlParameter");
					Smart::SMARTStateClient cdlStateClient(component, "smartCdlServer");

					str = "STRATEGY(ROTATE)";
					cmd.set(str);
					smartCdlParameterSendClient.send(cmd);
					str = "LOOKUPTABLE(DEFAULT)";
					cmd.set(str);
					smartCdlParameterSendClient.send(cmd);
					str = "GOALMODE(ABSOLUTE)";
					cmd.set(str);
					smartCdlParameterSendClient.send(cmd);

					str = "GOALREGION(-1000)(0)(0)";
					cmd.set(str);
					smartCdlParameterSendClient.send(cmd);
					itemNumber = 2;

					// CDL State --> GO!
					itemNumber = 2;
					cdlStateClient.getWaitMainStates(mainstates);
					// check input
					if( itemNumber <= mainstates.size() )
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for(unsigned int i=1; i < itemNumber; i++)
						{
							++iterator1;
						}
						// send selected state
						cdlStateClient.setWaitState( *iterator1 );
						std::cout << "state <" << *iterator1 << "> sent\n";
					}

					//Cdl Goal Event!!
					CHS::EventClient<Smart::CommCdlGoalEventParameter,Smart::CommCdlGoalEventResult> cdlGoalEventClient(component, "smartCdlServer","cdlGoalEvent");

					Smart::CommCdlGoalEventParameter parameter;
					Smart::CommCdlGoalEventResult result;
					CHS::EventId id;

					Smart::StatusCode status;
					int b;
					int a = 0;
					//
					// continuous event
					//
					parameter.set(a);

					status = cdlGoalEventClient.activate(CHS::single, parameter, id);

					status = cdlGoalEventClient.getEvent(id, result);
					if (status == Smart::SMART_OK)
					{
						result.get(b);
						std::cout << "event id: " << id << " event fired: " << b << "\n";
					}

					status = cdlGoalEventClient.deactivate(id);

					//Speechoutput
					CHS::SendClient<Smart::CommSpeechOutputMessage> smartSpeechSendClient(component, "smartSpeechOutputServer" ,"text2speech");
					smartSpeechSendClient.send(Smart::CommSpeechOutputMessage("Welcome to the smartsoft robotic framework!"));

					// CDL State --> STOP!
					itemNumber = 1;
					cdlStateClient.getWaitMainStates(mainstates);
					// check input
					if( itemNumber <= mainstates.size() )
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for(unsigned int i=1; i < itemNumber; i++)
						{
							++iterator1;
						}
						// send selected state
						cdlStateClient.setWaitState( *iterator1 );
						std::cout << "state <" << *iterator1 << "> sent\n";
					}
					break;
				}
	#endif


				////////////////////////////////////
				// Demo 2 move with planner and CDL
				////////////////////////////////////
				case 2:
				{
					int cdlId = 0;
					std::string inString;

					//GoalEventThread goalEventThread;

	//				std::cout << "\nActivate speech output? (y/n): ";
	//				std::cin >> inString;
	//				if (strcasecmp("n", inString.c_str()) != 0)
	//				{
	//					std::cout << "Speach output activated!\n";
	//					//Event Thread
	//					//goalEventThread.open();
	//					COMP->goalEventTask->start();
	//				}
					SmartACE::CommParameterResponse response;

					//PlannerNoPathEventThread plannerNoPathEventThread;
					//plannerNoPathEventThread.open();
					//COMP->plannerNoPathEventTask->start();

					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.MAPPERPARAMS.CURLTM(DISABLE)(10)"), response, "SmartMapperGridMap", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.MAPPERPARAMS.CUREMPTY(ACCUMULATE)"), response, "SmartMapperGridMap", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMIT"), response, "SmartMapperGridMap", "param");

					// set build both Map
					COMP->stateMaster->setWaitState("buildbothmaps", "SmartMapperGridMap", "state");

					// CDL SETUP

					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.SETSTRATEGY(APPROACH_HALT)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.FREEBEHAVIOR(ACTIVATE)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.LOOKUPTABLE(DEFAULT)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.TRANSVEL(0)(400)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.GOALMODE(PLANNER)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.APPROACHDIST(100)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMIT"), response, "SmartCdlServer", "param");


					// Planner Setup
					COMP->stateMaster->setWaitState("pathplanning", "SmartPlannerBreadthFirstSearch", "state");

					////////////////////
					//Goal 1 first goal
					////////////////////

					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.PLANNERPARAMS.DELETEGOAL"), response, "SmartPlannerBreadthFirstSearch", "param");

					//wait for connections to ensure a clean prompt
					sleep(1);

					std::cout << "Enter first goal in mm (x)(y) e.g. (1000)(1000): ";
					std::cin >> inString;
					str = "COMMNAVIGATIONOBJECTS.PLANNERPARAMS.SETDESTINATIONCIRCLE";
					str.append(inString);
					str.append("(100)");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest(str), response, "SmartPlannerBreadthFirstSearch", "param");


					//wait for communication planner-cdl
					sleep(1);
					//COMP->SpeechLock.release();

					itemNumber = 2;

					// CDL State --> GO!
					COMP->stateMaster->setWaitState("moverobot", "SmartCdlServer", "state");

					////////////////////////////
					//Goal X
					///////////////////////////


					while (true)
					{
						std::cout << "Enter another Goal? (y/n): ";
						std::cin >> inString;
						if (strcasecmp("n", inString.c_str()) != 0)
						{
							COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.PLANNERPARAMS.DELETEGOAL"), response, "SmartPlannerBreadthFirstSearch", "param");

							std::cout << "Next Goal in mm (x)(y):";
							std::cin >> inString;
							str = "COMMNAVIGATIONOBJECTS.PLANNERPARAMS.SETDESTINATIONCIRCLE";
							str.append(inString);
							str.append("(100)");
							COMP->paramMaster->sendParameterWait(lispParamToParameterRequest(str), response, "SmartPlannerBreadthFirstSearch", "param");

							//wait for communication planner-cdl
							sleep(1);
							//COMP->SpeechLock.release();

						} else
						{
							// CDL State --> STOP!
							COMP->stateMaster->setWaitState("Neutral", "SmartCdlServer", "state");
							COMP->stateMaster->setWaitState("Neutral", "SmartPlannerBreadthFirstSearch", "state");
							COMP->stateMaster->setWaitState("Neutral", "SmartMapperGridMap", "state");
							break;
						}

					}//while(true)

				} //case 2:


					///////////////////////////////////////
					// Demo 3 move with CDL in reactive mode
					///////////////////////////////////////
				case 3:
				{

	//				SmartACE::CommParameterRequest request;
					SmartACE::CommParameterResponse response;

					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.SETSTRATEGY(REACTIVE)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.FREEBEHAVIOR(ACTIVATE)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.LOOKUPTABLE(DEFAULT)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.TRANSVEL(0)(800)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMIT"), response, "SmartCdlServer", "param");

					std::cout << "To start the demo set CDL in moverobot state!\n";

					break;
				}

					///////////////////////////////////////////////
					// Demo 4 move with CDL controlled by joystick
					///////////////////////////////////////////////
				case 4:
				{
					SmartACE::CommParameterResponse response;

					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.SETSTRATEGY(JOYSTICK)"), response, "SmartCdlServer", "param");

					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.FREEBEHAVIOR(DEACTIVATE)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.LOOKUPTABLE(DEFAULT)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.TRANSVEL(-200)(500)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMNAVIGATIONOBJECTS.CDLPARAMETER.ROTVEL(-50)(50)"), response, "SmartCdlServer", "param");
					COMP->paramMaster->sendParameterWait(lispParamToParameterRequest("COMMIT"), response, "SmartCdlServer", "param");




					// CDL State --> GO!
					itemNumber = 2;
	//				COMP->stateMaster->getAllMainStates(mainstates);
					COMP->stateMaster->getAllMainStates(mainstates, "SmartCdlServer", "state");
					// check input
					if (itemNumber <= mainstates.size())
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for (unsigned int i = 1; i < itemNumber; i++)
						{
							++iterator1;
						}
						// send selected state
						COMP->stateMaster->setWaitState(*iterator1, "SmartCdlServer", "state");
						std::cout << "state <" << *iterator1 << "> sent\n";
					}

					break;
				} // case 4

	#if 0
					///////////////////////////////////////////////
					// Demo 5: following
					///////////////////////////////////////////////
				case 5:
				{
					//CHS::SendClient<Smart::CommCdlParameter> smartCdlParameterSendClient(component,"smartCdlServer","cdlParameter");
					std::cout << "connecting to: " << COMP->ini.cdlParameterClient.serverName << "; "
							<< COMP->ini.cdlParameterClient.serviceName << std::endl;
					status = COMP->cdlParameterClient->connect(COMP->ini.cdlParameterClient.serverName,
							COMP->ini.cdlParameterClient.serviceName);
					if (status != Smart::SMART_OK)
					{
						std::cout << "COULD NOT CONNECT TO cdl parameter" << std::endl;
					} else
					{
						std::cout << "connected.\n";
					}

					// CDL SETUP
					str = "STRATEGY(FOLLOW)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);
					str = "GOALMODE(PERSON)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);
					str = "LOOKUPTABLE(DEFAULT)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);
					str = "APPROACHDIST(600)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);
					//str = "TRANSVEL(0)(200)";
					str = "TRANSVEL(0)(200)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);
					str = "ROTVEL(-40)(40)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);

					std::cout << "To start the demo set CDL in moverobot state and laser tracker to follow!\n";

					break;
				} // case 5


					////////////////////////////////////
					// Demo 6 move with planner coverage
					////////////////////////////////////
				case 6:
				{
					int cdlId = 0;
					std::string inString;

					std::cout << "connecting to: " << COMP->ini.cdlStateClient.serverName << "; " << COMP->ini.cdlStateClient.serviceName
							<< std::endl;
					status = COMP->cdlStateClient->connect(COMP->ini.cdlStateClient.serverName, COMP->ini.cdlStateClient.serviceName);
					if (status != Smart::SMART_OK)
					{
						std::cout << "COULD NOT CONNECT TO state client" << std::endl;
					} else
					{
						std::cout << "connected.\n";
					}

					std::cout << "connecting to: " << COMP->ini.cdlParameterClient.serverName << "; "
							<< COMP->ini.cdlParameterClient.serviceName << std::endl;
					status = COMP->cdlParameterClient->connect(COMP->ini.cdlParameterClient.serverName,
							COMP->ini.cdlParameterClient.serviceName);
					if (status != Smart::SMART_OK)
					{
						std::cout << "COULD NOT CONNECT TO cdl parameter" << std::endl;
					} else
					{
						std::cout << "connected.\n";
					}

					// CDL SETUP
					str = "STRATEGY(APPROACH_COVERAGE)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);
					str = "FREEBEHAVIOR(DEACTIVATE)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);
					str = "LOOKUPTABLE(DEFAULT)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);
					str = "TRANSVEL(0)(400)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);
					str = "GOALMODE(PLANNER)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);
					str = "APPROACHDIST(100)";
					cmd.set(str);
					COMP->cdlParameterClient->send(cmd);

					// CDL State --> GO!
					itemNumber = 2;
					COMP->cdlStateClient->getAllMainStates(mainstates);
					// check input
					if (itemNumber <= mainstates.size())
					{
						// iterate to selected state
						std::list<std::string>::iterator iterator1 = mainstates.begin();
						for (unsigned int i = 1; i < itemNumber; i++)
						{
							++iterator1;
						}
						// send selected state
						COMP->cdlStateClient->setWaitState(*iterator1);
						std::cout << "state <" << *iterator1 << "> sent\n";
					}

				} //case 6:
	#endif

				default:
				{
					std::cout << "unsupported demo (maybe some ''#if 0'' in the sources?) !!!\n\n";
					break;
				}

				}
				break;
			} // case 99



			case 0:
			{
				exit(0);
				break;
			}

				// default
			default:
			{
				std::cout << "unsupported menu item (maybe some ''#if 0'' in the sources?) !!!\n\n";
				break;
			}

			} // switch( mainMenuItem )


	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int ConsoleTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
