//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2011, 2017 Matthias Lutz, Dennis Stampfer, Matthias Rollenhagen, Nayabrasul Shaik
//
//      lutz@hs-ulm.de
//      stampfer@hs-ulm.de
//      rollenhagen@hs-ulm.de
//      shaik@hs-ulm.de
//
//      ZAFH Servicerobotic Ulm
//      Christian Schlegel
//      University of Applied Sciences
//      Prittwitzstr. 10
//      89075 Ulm
//      Germany
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------
#include "ImageTask.hh"
#include "ComponentKinectV1Server.hh"

#include <iostream>
#include "EulerTransformationMatrices.hh"

ImageTask::ImageTask(SmartACE::SmartComponent *comp) 
:	ImageTaskCore(comp)
{
	std::cout << "constructor ImageTask\n";
	_ring_buffer_index = 0;
}
ImageTask::~ImageTask() 
{
	std::cout << "destructor ImageTask\n";
	COMP->imageTask->close();
	for (unsigned int i = 0; i < _ring_buffer.size() - 2; i++) {
		delete _ring_buffer[i];
	}
	_ring_buffer.clear();
}

void ImageTask::startCapturing() {
	SmartACE::SmartGuard guard(COMP->kinectMutex);
	if (COMP->device != NULL) {
		COMP->device->start_rgb_depth();
	}
	if (COMP->getGlobalState().getSettings().getDebug_info()) {
		std::cout << "[Image Task] Start capturing\n";
	}
}
void ImageTask::stopCapturing() {
	SmartACE::SmartGuard guard(COMP->kinectMutex);
	if (COMP->device != NULL) {
		COMP->device->stop_rgb_depth();
	}
	if (COMP->getGlobalState().getSettings().getDebug_info()) {
		std::cout << "[Image Task] Stop capturing\n";
	}
}


int ImageTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	// Calculate size of the ring_buffer
	int size = (int) (COMP->getGlobalState().getSettings().getValid_image_time() + 1);

	_ring_buffer.resize(size);

	if (COMP->getGlobalState().getSettings().getDebug_info()) {
		std::cout << "[Image Task] Newest: Size of Ring Buffer " << size << std::endl;
	}

	// Fill ring_buffer with empty images
	for (unsigned int i = 0; i < _ring_buffer.size(); i++) {
		_ring_buffer[i] = new DomainVision::CommRGBDImage;
	}

	return 0;
}
int ImageTask::on_execute()
{
	// this method is called from an outside loop,
		// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
		// also do not use blocking calls which do not result from smartsoft kernel

		// this method is triggered periodically with period time 250 ms
		// std::cout << "Hello from ImageTask  - periodic\n";

		CommBasicObjects::CommBasePose default_base_position;
		default_base_position.set_x(COMP->getGlobalState().getBase().getX());
		default_base_position.set_y(COMP->getGlobalState().getBase().getY());
		default_base_position.set_z(COMP->getGlobalState().getBase().getZ());

		// TODO: Check
		//default_base_position.set_base_alpha(COMP->ini.base.base_a);
		default_base_position.set_base_azimuth(COMP->getGlobalState().getBase().getBase_a());

		//default_base_position.set_steer_alpha(COMP->getGlobalState().getBase().getSteer_a());
		//default_base_position.set_turret_alpha(COMP->ini.base.turret_a);

		CommBasicObjects::CommBaseVelocity zero_velocity;
		zero_velocity.set_vX(0);
		zero_velocity.set_vY(0);
		zero_velocity.set_vZ(0);

	//	zero_velocity.set_omega_base(0);
	//	zero_velocity.set_omega_steer(0);
	//	zero_velocity.set_omega_turret(0);

		zero_velocity.set_WX_base(0);
		zero_velocity.set_WY_base(0);
		zero_velocity.set_WZ_base(0);

		DomainVision::CommRGBDImage* current_rgbd_image = NULL;

		try{
			Smart::StatusCode statusCode;
			statusCode = COMP->stateSlave->acquire("PushImage");
			std::cout<< Smart::StatusCodeConversion(statusCode) << std::endl;
			if(statusCode == Smart::SMART_OK)
			{

				current_rgbd_image = _ring_buffer[_ring_buffer_index];

				// get newest image from Kinect
				std::cout <<" Get Image: " << std::endl;
				SmartACE::SmartGuard guard(COMP->kinectMutex);

				COMP->device->get_rgbd_image(*current_rgbd_image);

				std::cout << "New image rcvd" << std::endl;
				guard.release();


	//
	//				IplImage *debugImage = OpenCVHelpers::copyRGBToIplImage((unsigned char*)image->get_rgb_image(), image->get_rgb_height(), image->get_rgb_width());
	//				cvSaveImage("kinect_rgb.jpg", debugImage);


			//	image->set_min_distance(COMP->getGlobalState().getHardware_properties().getMin_distance());
			//	image->set_max_distance(COMP->getGlobalState().getHardware_properties().getMax_distance());

				arma::mat sensorMat;
				EulerTransformationMatrices::create_zyx_matrix(COMP->getGlobalState().getSensor_pose().getX(), COMP->getGlobalState().getSensor_pose().getY(),
						COMP->getGlobalState().getSensor_pose().getZ(), COMP->getGlobalState().getSensor_pose().getAzimuth(), COMP->getGlobalState().getSensor_pose().getElevation(),
						COMP->getGlobalState().getSensor_pose().getRoll(), sensorMat);

				// set base state
				CommBasicObjects::CommBaseState base_state;

				//////////////
				if (COMP->getGlobalState().getBase().getOn_ptu()) {
					CommBasicObjects::CommDevicePoseState devicePoseState;
					Smart::StatusCode status = COMP->ptuPosePushNewestClient->getUpdate(devicePoseState);

					base_state = devicePoseState.get_base_state();
					CommBasicObjects::CommPose3d ptuPose = devicePoseState.get_device_pose3d_robot();
					arma::mat ptuMat = ptuPose.getHomogeneousMatrix();

					sensorMat = ptuMat * sensorMat;

					if (status != Smart::SMART_OK) {
						std::cerr << "[Image Task] WARNING: failed to get current ptu device state ("
						<< Smart::StatusCodeConversion(status) << "), pushing invalid image" << std::endl;
			//			image->set_data_valid(false);
					}
				}
				//////////////

				// read base state from base server
				if (COMP->getGlobalState().getBase().getOn_base()) {
					Smart::StatusCode status = COMP->basePushTimedClient->getUpdate(base_state);

					if (status != Smart::SMART_OK) {
						std::cerr << "[Image Task] WARNING: failed to get current base state ("
						<< Smart::StatusCodeConversion(status) << "), pushing invalid image" << std::endl;
			//			image->set_data_valid(false);
					}
				}
				// default base state
				else {
					base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
					base_state.set_base_position(default_base_position);
					base_state.set_base_velocity(zero_velocity);
				}

				CommBasicObjects::CommPose3d sensorPose(sensorMat);

			//	image->set_sensor_pose(sensorPose);
			//	image->set_base_state(base_state);
				current_rgbd_image->setSensor_pose(sensorPose);
				current_rgbd_image->setBase_state(base_state);

				// Save the newest image into the global pointer
				COMP->NewestImageMutex.acquire();
				COMP->newestImage = current_rgbd_image;
				COMP->NewestImageMutex.release();

				//std::cout << "color image width x height:" << colorImage.get_width() << " x " << colorImage.get_height() << std::endl;
				COMP->colorImagePushNewestServer->put(current_rgbd_image->getColor_image());
				COMP->depthPushNewestServer->put(current_rgbd_image->getDepth_image());
				COMP->imagePushNewestServer->put(*current_rgbd_image);

				if (COMP->getGlobalState().getSettings().getDebug_info()) {
					std::cout << "[Image Task] Newest: Image sent!\n";
					std::cout << "[Image Task] Newest Color: Image sent!\n";
					//std::cout << "[Image Task] Image is " << ((image->is_data_valid()) ? "valid" : "invalid") << "\n";
				}

				// calculate new index in the ring_buffer
				_ring_buffer_index++;
				if (_ring_buffer_index == _ring_buffer.size())
					_ring_buffer_index = 0;

				guard.release();
				COMP->stateSlave->release("pushimage");

			}//			if(COMP->stateServer->acquire("active") == CHS::SMART_OK)

		} catch (std::exception e) {
			std::cerr << "[Image Task] Error in ImageTask::svc() " << e.what() << "\n";
		} catch (...) {
			std::cerr << "[Image Task] Unknown error in ImageTask::svc()\n";
		}

		// TODO: Check
		//smart_task_wait_period();

		// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
		return 0;
}
int ImageTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
