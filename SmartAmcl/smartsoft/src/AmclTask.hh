//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// CREDITS:
//
// The code for the amcl algorithm was taken from the
// Playerstage Project, which is distributed under GPL, and you can find at
// http://playerstage.sourceforge.net/
//
// Player - One Hell of a Robot Server
// Copyright (C) 2000
//    Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
//
//----------------------------------------------------------------------------

#ifndef _AMCLTASK_HH
#define _AMCLTASK_HH

#include "AmclTaskCore.hh"

#include "AmclTypes.hh"
#include <libgen.h>
	
class AmclTask  : public AmclTaskCore
{
private:

	// sensor objects
//	AMCLOdom* odom_;
//	AMCLLaser* laser_;
	bool laser_update_;

	pf_vector_t pf_odom_pose_;

	int resample_interval_;
	int resample_count_;

public:
	AmclTask(SmartACE::SmartComponent *comp);
	virtual ~AmclTask();
	
	int init(const std::string& filename);

	virtual int on_entry();
	virtual int on_execute();
	virtual int on_exit();

private:


//    VisualizationHelper h;


	map_t* loadMapFromFile(const std::string& fname, double res, bool negate, double occ_th, double free_th,
			double* origin);

	static double normalize(double z) {
		return atan2(sin(z), cos(z));
	}

	static double angle_diff(double a, double b) {

		double d1, d2;
		a = normalize(a);
		b = normalize(b);
		d1 = a - b;
		d2 = 2* M_PI - fabs(d1);

		if (d1 > 0) {
			d2 *= -1.0;
		}

		if (fabs(d1) < fabs(d2)) {
			return (d1);
		} else {
			return (d2);
		}
	}

	static double pi_to_pi(double angle) {
		angle += M_PI;
		double ret_angle = fmod(angle, 2* M_PI );

		if (angle < 0)
			ret_angle += 2* M_PI ;

		ret_angle -= M_PI;

		return ret_angle;
	}
};

#endif
