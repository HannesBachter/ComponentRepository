//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

#include "TriggerHandler.hh"

#include "SmartGMapping.hh"

// includes for map serialization
#include <fstream>
#include <cxcore.h>
#include <highgui.h>

// trigger user methods
void TriggerHandler::handleCommNavigationObjects_GMappingParameter_INITNEWMAP(const int &x, const int &y, const int &a)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	std::cout<<"INIT_NEW_MAP x: "<<x<<" y: "<<y<<" phi: "<<a<<std::endl;
	Smart::StatusCode status;
	//TODO check if there could be deadlock on component startup
	// if the task is started initGMappingProcessor is called from task thread if the laser data takes some time (LMS100 startup)
	// if this parameter is send to the component the same method is called from component thread and block the component completely!
	status = COMP->stateSlave->tryAcquire("nonneutral");
	if(status != CHS::SMART_OK){
		COMP->gMappingTask->initGMappingProcessor(x, y, a);
	} else
	{
		std::cout<<"[WARNING]: Componente is active --> INIT_NEW_MAP not allowed!"<<std::endl;
		COMP->stateSlave->release("nonneutral");
	}
	std::cout<<"INIT_NEW_MAP PARM DONE"<<std::endl;
}
void TriggerHandler::handleCommNavigationObjects_GMappingParameter_SAVEMAP(const std::string &dirname, const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	if(COMP->mymap==NULL)
	{
		std::cout<<"No map inizialized!"<<std::endl;
		return;
	}

	COMP->mapLock.acquire();
	// map context informations
	const unsigned map_size_x = COMP->mymap->getMapSizeX();
	const unsigned map_size_y = COMP->mymap->getMapSizeY();
	double resolution = COMP->mymap->getResolution();
	GMapping::Point origin = COMP->mymap->map2world(GMapping::IntPoint(0, 0));

	double origin_x = origin.x;
	double origin_y = origin.y;
	double origin_z = 0.0;

	bool negate = false;
	double occupied_thresh = 0.65;
	double free_thresh = 0.196;

	const char occupied = 0;
	const char unknown = 205;
	const char freeSpace = 255;

	try	{

	// create a single channel image with the same size and double depth as the map
	//	IplImage* image = cvCreateImage(cvSize(map_size_x, map_size_y), IPL_DEPTH_64F, 1);
	IplImage* image = cvCreateImage(cvSize(map_size_x, map_size_y), IPL_DEPTH_8U, 1);

	// copy map into a image
	double value = 0.0;

	//				char scaledValue = 0;
	for (unsigned int y = 0; y < map_size_y; y++)
	{
		for (unsigned int x = 0; x < map_size_x; x++)
		{
			char* ptr = image->imageData + (y * image->widthStep) + x;
			value = COMP->mymap->cell((int)x, (int)y);

			/*						if(value < free_thresh && value >= 0.0) // is cell free
						{
			 *ptr = freeSpace;
						}
						else if(value > occupied_thresh) // is cell occupied
						{
			 *ptr = occupied;
						}
						else if(value < occupied_thresh && value > free_thresh)// cell state is unknown
						{
			 *ptr = unknown;
						}
						else // handle initial values lower than 0
						{
			 *ptr = unknown;
						}

			 */
			if(value < 0.0)
			{
				*ptr = unknown;
			}
			else if(value > free_thresh)
			{
				*ptr = occupied;
			}
			else
			{
				*ptr = freeSpace;
			}

		}
	}
	cvFlip(image, NULL, 0); // 0 == horizontal flip


	char  mapFileName[255];
	char  mapFileNameWithPath[255];
	sprintf(mapFileName,"%s.pgm", filename.c_str());
	sprintf(mapFileNameWithPath,"%s/%s.pgm", dirname.c_str(), filename.c_str());
	// save image to file mapAsPGM.pgm
	if(!cvSaveImage(mapFileNameWithPath,image)) std::cout << "Could not save: " << mapFileNameWithPath << std::endl;

	// save context information in yaml format
	char  yamlFileName[255];
	sprintf(yamlFileName,"%s/%s.yaml", dirname.c_str(), filename.c_str());
	CvFileStorage* fs = cvOpenFileStorage( yamlFileName, 0, CV_STORAGE_WRITE);
	cvWriteString( fs, "image", mapFileName);
	cvWriteReal( fs, "resolution", resolution);

	cvWriteInt( fs, "negate", negate);
	cvWriteReal( fs, "occupied_thresh", occupied_thresh);
	cvWriteReal( fs, "free_thresh", free_thresh);
	cvReleaseFileStorage( &fs );

	ofstream myfile;
	myfile.open(yamlFileName, ios::app);
	myfile << "origin: " << "[" << origin_x << "," << origin_y << "," << origin_z << "]\n";
	myfile.close();

	// clean up image
	cvReleaseImage(&image);

	COMP->mapLock.release();
	std::cout << "GMAPPING_SAVE_MAP: saved - " << mapFileNameWithPath << "\n";
	}
	catch (cv::Exception& e){
		const char* err_msg = e.what();
		std::cout << "exception caught: " << err_msg << std::endl;
		std::cout<<"ERROR: Could not save map!"<<std::endl;
	}
}
