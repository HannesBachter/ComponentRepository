//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//------------------------------------------------------------------------
//
//  Copyright (C) 2010 Manuel Wopfner
//
//        wopfner@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "SmartLaserHokuyoURGServer2 component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------
#include "LaserTask.hh"
#include "ComponentLaserHokuyoURGServer.hh"

#include "WatchDogTask.hh"

#include <EulerTransformationMatrices.hh>

#include <string>
#include <ctime>
#include <iostream>

LaserTask::LaserTask(SmartACE::SmartComponent *comp) 
:	LaserTaskCore(comp)
{
	_default_base_position.set_x(COMP->getGlobalState().getBase_manipulator().getX());
	_default_base_position.set_y(COMP->getGlobalState().getBase_manipulator().getY());
	_default_base_position.set_z(COMP->getGlobalState().getBase_manipulator().getZ());
	_default_base_position.set_base_azimuth(COMP->getGlobalState().getBase_manipulator().getBase_azimuth());
	_default_base_position.set_base_elevation(COMP->getGlobalState().getBase_manipulator().getBase_elevation());
	_default_base_position.set_base_roll(COMP->getGlobalState().getBase_manipulator().getBase_roll());

	zero_velocity.set_vX(0);
	zero_velocity.set_vY(0);
	zero_velocity.set_vZ(0);
	zero_velocity.setWX(0);
	zero_velocity.setWY(0);
	zero_velocity.setWZ(0);
	// set scan id counter to 0
	scan_id = 0;
}

bool LaserTask::accquireNewScan(CommBasicObjects::CommMobileLaserScan& scan, ParameterStateStruct& localState) {


	if (localState.getScanner().getVerbose())
		std::cout << "[Laser Task] read new laser data\n";


	hokuyo::LaserScan raw_scan =laser.getNextScan();

	if (localState.getScanner().getVerbose())
		std::cout << "[Laser Task] Got new laser data\n";

//	std::cout<<"DEBUG: "<<raw_scan.ranges.size()<<" "<<raw_scan.ranges[250]<<std::endl;
//	std::cout<<"raw_scan.config.range_res: "<<raw_scan.config.ang_increment*180/M_PI<<std::endl;
//	std::cout<<"opening: "<<(int)((raw_scan.config.max_angle - raw_scan.config.min_angle)*180/M_PI)<<std::endl;

	// set scan header
	//scan.set_scan_time_stamp(CommBasicObjects::CommTimeStamp(raw_scan.get_receive_timestamp()));
	scan.set_scan_update_count(scan_id);

	//////////////////////////
	// set scan parameters
	//////////////////////////
	if (COMP->getGlobalState().getScanner().getVerbose()) {
		std::cout << "set scan parameters\n";
	}

	const unsigned int min_dist = localState.getScanner().getMin_range();
	const unsigned int max_dist = localState.getScanner().getMax_range();


	scan.set_scan_length_unit(1);
	//		scan.set_scan_double_field_of_view(-0.5 * laser.get_opening_angle() + laser.get_resolution(), laser.get_resolution());
	scan.set_scan_double_field_of_view(-0.5 * (localState.getScanner().getOpening_angle()) + (raw_scan.config.ang_increment*180/M_PI),
			(raw_scan.config.ang_increment*180/M_PI));

//	std::cout<<"DEBUG field of view: "<<-0.5 * (localState.getScanner().getOpening_angle()) + (raw_scan.config.ang_increment*180/M_PI)<<" "<<
//				(raw_scan.config.ang_increment*180/M_PI)<<std::endl;
	scan.set_min_distance(min_dist);
	scan.set_max_distance(max_dist);

	//////////////////////////
	// set scan points
	//////////////////////////

	const int desiredScans = localState.getScanner().getOpening_angle()*100 / ((raw_scan.config.ang_increment*180/M_PI) * 100.0);
	const int rangerScans = ((raw_scan.config.max_angle - raw_scan.config.min_angle)*180/M_PI) / (raw_scan.config.ang_increment*180/M_PI);

	if (COMP->getGlobalState().getScanner().getVerbose()) {
		std::cout<<"desiredScans: "<<desiredScans<<" rangerScans: "<<rangerScans<<std::endl;
		std::cout<<"max_angle: "<<raw_scan.config.max_angle<<" min_angle: "<<raw_scan.config.min_angle <<" ang_increment: "<<raw_scan.config.ang_increment <<std::endl;
	}


	scan.set_max_scan_size(desiredScans);
	const uint32_t firstScanIndex = (rangerScans - desiredScans) * 0.5;
	uint32_t lastScanIndex = rangerScans - firstScanIndex;

	if (lastScanIndex > raw_scan.ranges.size())
		lastScanIndex = raw_scan.ranges.size();

	if (COMP->getGlobalState().getScanner().getVerbose()) {
		std::cout << "Read scans: " << raw_scan.ranges.size() << "\n";
		std::cout<<" Max possible size: "<<desiredScans<<std::endl;
		std::cout<<" firstScanIndex: " <<firstScanIndex<<std::endl;
		std::cout<<" lastScanIndex: " <<lastScanIndex<<std::endl;
		std::cout<<" min_dist: " <<min_dist<<std::endl;
		std::cout<<" max_dist: " <<max_dist<<std::endl;
	}

	uint32_t num_valid_points = 0;
	for (uint32_t i = firstScanIndex; i < lastScanIndex; ++i) {
		const double dist = 1000*raw_scan.ranges[i];
		if (dist >= min_dist && dist <= max_dist) {
			++num_valid_points;
		}
	}

	scan.set_scan_size(num_valid_points);

	if (COMP->getGlobalState().getScanner().getVerbose()) {
		std::cout<<" num_valid_points: " <<num_valid_points<<std::endl;
		std::cout<<" raw_scan.intensities[i].size: "<<raw_scan.intensities.size()<<std::endl;
	}

	uint32_t valid_point_index = 0;
	for (uint32_t i = firstScanIndex; i < lastScanIndex; ++i) {
		const double dist = 1000*raw_scan.ranges[i];
		if (dist >= min_dist && dist <= max_dist) {
			scan.set_scan_index(valid_point_index, i - firstScanIndex);
			scan.set_scan_integer_distance(valid_point_index,::rint(dist));
			//scan.set_scan_intensity(valid_point_index, raw_scan.intensities[i]);
			++valid_point_index;
		}
	}

	scan.set_scan_valid(true);
	scan_id++;

	return true;

}

bool LaserTask::openLaser()
{
	WatchDogTask::watchDogReset();
	if( laser.Driver::CLOSED == laser.getState() )
	{
		std::cout << "[Laser Task] try to open device " << COMP->getGlobalState().getScanner().getDevice() << " ... ";

		laser.doOpen();
		WatchDogTask::watchDogReset();
		if( laser.Driver::OPENED == laser.getState() )
		{
			std::cout << "Success\n";

			std::cout << "[Laser Task] try to start device " << COMP->getGlobalState().getScanner().getDevice() << " ... ";
			laser.doStart();
			WatchDogTask::watchDogReset();
			if( laser.Driver::RUNNING == laser.getState() )
			{
				std::cout << "Starting Laser stream Success\n";
			}
			else
			{
				std::cout << "Starting Laser stream Failed\n";
				return false;
			}
		}
		else
		{
			std::cout << "Connecting to Laser port Failed\n";
			return false;
		}
	}

	return true;
}
LaserTask::~LaserTask() 
{
	std::cout << "destructor LaserTask\n";
}



int LaserTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	// open device

	HokuyoDriverConfig cfg = laser.config();
	cfg.port = COMP->getGlobalState().getScanner().getDevice();
	cfg.min_angle = ((COMP->getGlobalState().getScanner().getOpening_angle())/2.0)/180*M_PI*-1;
	cfg.max_angle = ((COMP->getGlobalState().getScanner().getOpening_angle())/2.0)/180*M_PI;
	cfg.intensity = false;
	laser.config_update(cfg);

	WatchDogTask::watchDogStart();

	openLaser();


	return 0;
}
int LaserTask::on_execute()
{
	// this method is called from an outside loop,
		// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
		// also do not use blocking calls which do not result from smartsoft kernel

		   //block here when component not in active state
	//		COMP->smartStateSlave->acquire("active");
	//		COMP->smartStateSlave->release("active");


		if(false == openLaser())
		{
			ACE_OS::sleep(ACE_Time_Value(0,500000));
			return 0;
		}

		WatchDogTask::watchDogReset();

			ParameterStateStruct localState = COMP->getGlobalState();

			if (accquireNewScan(scan,localState)) {
				bool scan_is_valid = false;

				//////////////////////////
				// set base state
				//////////////////////////
				if (localState.getScanner().getVerbose())
					std::cout << "[Laser Task] set base state\n";

				// read base state from manipulator
				if (localState.getBase_manipulator().getOn_manipulator()) {
					Smart::StatusCode status = COMP->manipulatorTimedClient->getUpdate(mobile_manipulator_state);
					manipulator_state = mobile_manipulator_state.get_manipulator_state();
					base_state = mobile_manipulator_state.get_base_state();

					if (status == Smart::SMART_OK) {
						scan_is_valid = manipulator_state.is_valid();

						if (localState.getScanner().getVerbose()) {
							manipulator_state.print();
							std::cout.flush();
						}
					} else {
						std::cerr << "[Laser Task] WARNING: failed to get current manipulator state ("
								<< Smart::StatusCodeConversion(status) << "), pushing invalid scan" << std::endl;
						scan.set_scan_valid(false);
					}
				}
				// read base state from base server
				else if (localState.getBase_manipulator().getOn_base()) {
					Smart::StatusCode status = COMP->baseTimedClient->getUpdate(base_state);

					if (status == Smart::SMART_OK) {
						scan_is_valid = true;

						if (localState.getScanner().getVerbose()) {
							std::cout<< base_state<<std::endl;
						}
					} else {
						std::cerr << "[Laser Task] WARNING: failed to get current base state ("
								<< Smart::StatusCodeConversion(status) << "), pushing invalid scan" << std::endl;
						scan.set_scan_valid(false);
					}
				}
				// default base state
				else {
					//TODO
					//base_state.set_time_stamp(CommBasicObjects::CommTimeStamp(laser.get_receive_timestamp()));
					base_state.set_base_position(_default_base_position);
					base_state.set_base_velocity(zero_velocity);
					scan_is_valid = true;
				}
				scan.set_base_state(base_state);

				//////////////////////////
				// set robot scanner position
				//////////////////////////
				double x = localState.getScanner().getX();
				double y = localState.getScanner().getY();
				double z = localState.getScanner().getZ();
				double azimuth = localState.getScanner().getAzimuth();
				double elevation = localState.getScanner().getElevation();
				double roll = localState.getScanner().getRoll();
				arma::mat mat_sensor;

				if (localState.getBase_manipulator().getOn_manipulator() && scan_is_valid) {
					arma::mat mat_offset(4, 4);
					EulerTransformationMatrices::create_zyx_matrix(x, y, z, azimuth, elevation, roll, mat_offset);

					arma::mat mat_tcp(4, 4);
					double tcp_x, tcp_y, tcp_z, tcp_azimuth, tcp_elevation, tcp_roll;
					manipulator_state.get_pose_TCP_manipulator(tcp_x, tcp_y, tcp_z, tcp_azimuth, tcp_elevation, tcp_roll);
					EulerTransformationMatrices::create_zyx_matrix(tcp_x, tcp_y, tcp_z, tcp_azimuth, tcp_elevation,
							tcp_roll, mat_tcp);

					arma::mat mat_manipulator(4, 4);
					double man_x, man_y, man_z, man_azimuth, man_elevation, man_roll;
					manipulator_state.get_pose_manipulator(man_x, man_y, man_z, man_azimuth, man_elevation, man_roll);
					EulerTransformationMatrices::create_zyx_matrix(man_x, man_y, man_z, man_azimuth, man_elevation,
							man_roll, mat_manipulator);

					mat_sensor = mat_manipulator * mat_tcp * mat_offset;

				} else {
					EulerTransformationMatrices::create_zyx_matrix(x, y, z, azimuth, elevation, roll, mat_sensor);
				}

				CommBasicObjects::CommPose3d sensor_pose(mat_sensor);
				scan.set_sensor_pose(sensor_pose);

				//////////////////////////
				// set world scanner position
				//////////////////////////
				double base_x = 0;
				double base_y = 0;
				double base_z = 0;
				double base_a = 0;
				arma::mat mat_base(4, 4);

				if (scan_is_valid) {
					base_x = base_state.get_base_position().get_x();
					base_y = base_state.get_base_position().get_y();
					base_z = base_state.get_base_position().get_z();
					base_a = base_state.get_base_position().get_base_azimuth();

				}

				EulerTransformationMatrices::create_zyx_matrix(base_x, base_y, base_z, base_a, 0, 0, mat_base);
				arma::mat mat_world = mat_base * mat_sensor;
				CommBasicObjects::CommPose3d world_pose(mat_world);

				scan.set_scanner_x(world_pose.get_x());
				scan.set_scanner_y(world_pose.get_y());
				scan.set_scanner_z(world_pose.get_z());

				scan.set_scanner_azimuth(world_pose.get_azimuth());
				scan.set_scanner_elevation(world_pose.get_elevation());
				scan.set_scanner_roll(world_pose.get_roll());

				//////////////////////////
				// send scan to clients
				//////////////////////////
				if (localState.getScanner().getVerbose())
					std::cout << "[Laser Task] send scan to clients\n";

				if (localState.getServices().getActivate_push_newest()) {
					Smart::StatusCode push_status = COMP->laserPushNewestServer->put(scan);
					if (push_status != Smart::SMART_OK) {
						std::cerr << "[Laser Task] WARNING: error on push (" << Smart::StatusCodeConversion(push_status)
								<< ")" << std::endl;
					}
				}

				// copy local scan to global scan
				SmartACE::SmartGuard scan_guard(COMP->ScanLock);
				COMP->global_scan = scan;
				scan_guard.release();

				if (localState.getScanner().getVerbose()) {
					const unsigned int index = scan.get_scan_size() / 2;
					std::cout << "[Laser Task] Scan " << scan_id << " sent." << " Scan Position " << index << "/"
							<< scan.get_scan_size() << " = " << scan.get_scan_distance(index) << " mm" << std::endl;
				}
			} else {
				std::cerr << "[Laser Task] WARNING: received unexpected packet type" << std::endl;
			}

		// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
		return 0;
}
int LaserTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	// close laser device
	laser.doStop();
	laser.doClose();
	std::cout<<"[on_exit]: device closed!"<<std::endl;
	return 0;
}
