//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft Mapper/GridMapper component".
//  It provides mapping services based on grid maps. The current map
//  represents the latest snapshot of the local surrounding based on
//  laserscans. The current map can be preoccupied by the longterm map.
//  The longterm map is a simple occupancy grid map.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "CurMapTask.hh"
#include "SmartMapperGridMap.hh"

#include <iostream>

CurMapTask::CurMapTask(Smart::IComponent *comp) 
:	CurMapTaskCore(comp)
{
	std::cout << "constructor CurMapTask\n";
}
CurMapTask::~CurMapTask() 
{
	std::cout << "destructor CurMapTask\n";
}



int CurMapTask::on_entry()
{
	return 0;
}
int CurMapTask::on_execute()
{
	int status;
	Smart::StatusCode statusCode;
	int local_ltm_threshold;
	bool local_ltm_state;

	  // current map autoupdate service is activated

	  localState = COMP->getGlobalState();
	  local_ltm_threshold = COMP->ltm_threshold;
	  local_ltm_state = COMP->ltm_state;

	  // wait for scan (PushNewest)
	  statusCode = COMP->laserServiceIn->getUpdateWait(laserscan);
	  if (statusCode == Smart::SMART_OK)
	  {
		  // laserscan received
		  updateCounter++;
		  if (updateCounter >= localState.getCurrentMap().getInterval())
		  {
			  //
			  // generate current map and send it via autoupdate to clients
			  //
			  updateCounter=0;
			  if(localState.getGeneral().getVerbose() == true)
			  {
				  std::cout << "MAPPER: autoupdate current map: generate current map\n";
			  }

			  COMP->CurLock.acquire();

			  if (localState.getCommNavigationObjects().getMapperParams().getCUREMPTY().getMapmode() == ParameterStateStruct::CommNavigationObjectsType::MapperParamsType::CUREMPTYType::mapmodeType::ACCUMULATE)
			  {
				  // accumulating mode for current map
				  // convert obstacle growing cells into normal occupied cells
				  status = COMP->currentGridMap->convertObstacleGrowing();
				  if(localState.getGeneral().getVerbose() == true)
				  {
					  std::cout << "MAPPER: autoupdate current map: accumulating mode\n";
				  }
			  }
			  else
			  {
				  // delete current map for each cycle
				  status = COMP->currentGridMap->clearMap();
				  if(localState.getGeneral().getVerbose() == true)
				  {
					  std::cout << "MAPPER: autoupdate current map: clear map\n";
				  }
			  }

			  if (local_ltm_state==0)
			  {
				  // don't use the ltm for preoccupation
				  if(localState.getGeneral().getVerbose() == true)
				  {
					  std::cout << "MAPPER: autoupdate current map: no preoccupation\n";
				  }
			  }
			  else
			  {
				  // use ltm for preoccupation
				  COMP->LtmLock.acquire();


				  status = COMP->currentGridMap->setLtmOccupation(local_ltm_threshold,
										   *(COMP->ltmGridMap));

				  COMP->LtmLock.release();
				  if(localState.getGeneral().getVerbose() == true)
				  {
					  std::cout << "MAPPER: autoupdate current map: ltm preoccupation\n";
				  }
			  }

			  // now update map with current laserscan
			  status = COMP->currentGridMap->update(laserscan);

			  // send it via autoupdate to subscribed clients
			  CommNavigationObjects::CommGridMap gm;
			  gm = (CommNavigationObjects::CommGridMap)(*(COMP->currentGridMap));
			  COMP->currMapOut->put( gm );
			  COMP->CurLock.release();

			  if(localState.getGeneral().getVerbose() == true)
			  {
				  std::cout << "MAPPER: autoupdate current map: sent to subscribed clients\n";
			  }
		  }
		  else
		  {
			  // not yet the nth update cycle
			  if(localState.getGeneral().getVerbose() == true)
			  {
				  std::cout << "MAPPER: autoupdate current map: No update, cycle number ";
				  std::cout << updateCounter << "\n";
			  }
		  }
	  } // if (statusCode == Smart::SMART_OK)
	  else
	  {
		  std::cout << "MAPPER: did not receive laser scan. " << statusCode << std::endl;
		  if(statusCode == Smart::SMART_UNSUBSCRIBED)
		  {
			  std::cout << "MAPPER: laserClient is unsubscribed (maybe is rewired) -> try to subscribe again" << std::endl;
			  statusCode = COMP->laserServiceIn->subscribe();
			  std::cout << "MAPPER: laserClient subscription returned with " << statusCode << std::endl;
		  }
	  }
	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int CurMapTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
